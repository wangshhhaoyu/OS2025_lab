# Lab5 实验报告：用户进程管理

## 一、实验概述

本实验在 Lab4 的基础上，实现了用户进程的创建和管理功能，包括：
- 加载用户程序并正确设置用户态执行环境
- 实现进程 fork 时的内存空间复制
- 完善进程的生命周期管理（fork/exec/wait/exit）

实验环境：
- 操作系统：uCore on RISC-V 64
- 工具链：riscv64-unknown-elf-gcc
- 模拟器：QEMU

## 二、练习1：加载应用程序并执行

### 1.1 实验要求

完成 `load_icode` 函数中第6步的 trapframe 设置，使得用户程序能够正确从内核态返回到用户态执行。

需要设置以下寄存器：
- `tf->gpr.sp`：用户栈指针
- `tf->epc`：用户程序入口点
- `tf->status`：处理器状态寄存器

### 1.2 实现代码

```c
// 在 kern/process/proc.c 的 load_icode 函数中
tf->gpr.sp = USTACKTOP;
// 设置程序入口点（ELF文件的入口地址）
tf->epc = elf->e_entry;

// 设置状态寄存器，允许用户模式并设置正确的中断标志
// SSTATUS_SPP: 1表示之前的权限模式为Supervisor，0表示User
// SSTATUS_SPIE: Supervisor模式下中断使能
// 我们需要设置从用户模式开始，所以清除SPP位
// 设置SPIE位使能中断
tf->status = sstatus;
// 清除SPP位，表示从用户模式进入
tf->status &= ~SSTATUS_SPP;
// 设置SPIE位，使能中断
tf->status |= SSTATUS_SPIE;
// 清除SIE位，在返回用户模式前禁用中断
tf->status &= ~SSTATUS_SIE;
```

### 1.3 实现说明

#### （1）用户栈指针设置
```c
tf->gpr.sp = USTACKTOP;
```
将用户栈指针设置为用户栈顶地址 `USTACKTOP`（0x80000000）。用户栈向下增长，初始时指向栈顶。

#### （2）程序入口点设置
```c
tf->epc = elf->e_entry;
```
`epc` (Exception Program Counter) 寄存器保存了 `sret` 指令返回后要执行的地址。这里设置为 ELF 文件头中指定的程序入口地址，使得从内核态返回时能够跳转到用户程序的起始位置。

#### （3）状态寄存器设置
在 RISC-V 中，`sstatus` 寄存器的关键位包括：
- **SPP (Supervisor Previous Privilege)**：保存进入 Supervisor 模式前的特权级
  - 0 = User mode
  - 1 = Supervisor mode
- **SPIE (Supervisor Previous Interrupt Enable)**：保存进入 Supervisor 模式前的中断使能状态
- **SIE (Supervisor Interrupt Enable)**：当前 Supervisor 模式下的中断使能

设置过程：
1. 保留原有的 `sstatus` 值作为基础
2. 清除 `SPP` 位（`&= ~SSTATUS_SPP`），使 `sret` 返回到用户模式
3. 设置 `SPIE` 位（`|= SSTATUS_SPIE`），使返回用户态后能够响应中断
4. 清除 `SIE` 位（`&= ~SSTATUS_SIE`），在返回前保持内核态中断关闭

### 1.4 执行流程

当 `load_icode` 完成后，通过以下流程返回用户态：
1. `do_execve` → `load_icode` 设置好 trapframe
2. 返回到 `sys_exec` → `syscall` → `__trapret`
3. `__trapret` 中的 `RESTORE_ALL` 宏恢复所有寄存器
4. `sret` 指令：
   - 将 `sepc` 的值加载到 `pc`，跳转到用户程序入口
   - 根据 `sstatus.SPP` 切换特权级到 User mode
   - 根据 `sstatus.SPIE` 恢复中断使能状态

---

## 三、练习2：父进程复制自己的内存空间给子进程

### 2.1 实验要求

完成 `copy_range` 函数，实现在进程 fork 时将父进程的内存页复制到子进程。

需要完成的步骤：
1. 获取源页面的内核虚拟地址
2. 获取目标页面的内核虚拟地址
3. 复制内存内容
4. 建立新页面到线性地址的映射

### 2.2 实现代码

```c
// 在 kern/mm/pmm.c 的 copy_range 函数中
// (1) 获取源页面的内核虚拟地址
uintptr_t src_kvaddr = (uintptr_t)page2kva(page);
// (2) 获取目标页面的内核虚拟地址
uintptr_t dst_kvaddr = (uintptr_t)page2kva(npage);
// (3) 复制内存内容
memcpy((void *)dst_kvaddr, (void *)src_kvaddr, PGSIZE);
// (4) 建立新页面到线性地址的映射
ret = page_insert(to, npage, start, perm);
```

### 2.3 实现说明

#### （1）获取源页面的内核虚拟地址
```c
uintptr_t src_kvaddr = (uintptr_t)page2kva(page);
```
- `page` 是父进程的物理页框（Page 结构体）
- `page2kva()` 将物理页框转换为内核虚拟地址
- 内核需要通过虚拟地址访问物理内存

#### （2）获取目标页面的内核虚拟地址
```c
uintptr_t dst_kvaddr = (uintptr_t)page2kva(npage);
```
- `npage` 是为子进程新分配的物理页框
- 同样需要转换为内核虚拟地址才能访问

#### （3）复制内存内容
```c
memcpy((void *)dst_kvaddr, (void *)src_kvaddr, PGSIZE);
```
- 使用 `memcpy` 将一整页（PGSIZE = 4096 字节）的内容从父进程页面复制到子进程页面
- 这样子进程就获得了父进程内存的完整副本

#### （4）建立页表映射
```c
ret = page_insert(to, npage, start, perm);
```
- `to`：子进程的页目录
- `npage`：子进程的物理页框
- `start`：虚拟地址
- `perm`：页面权限（从父进程页表项中提取）
- `page_insert()` 在子进程的页表中建立虚拟地址到物理页框的映射

### 2.4 Copy-on-Write 机制说明

虽然本实验采用的是直接复制（实际复制内存）的方式，但注释中提到了 Copy-on-Write (COW) 机制：

**COW 的基本思想：**
- Fork 时不立即复制内存，而是让父子进程共享同一物理页
- 将共享页设置为只读
- 当任一进程尝试写入时，触发页错误
- 此时才真正分配新页并复制内容

**优势：**
- 节省内存（如果子进程只读取不修改）
- 加快 fork 速度（延迟复制）
- 适用于 fork 后立即 exec 的场景

本实验采用直接复制是因为实现简单，且确保了父子进程的内存完全独立。

---

## 四、练习3：进程管理机制分析

### 3.1 fork/exec/wait/exit 的执行流程

#### 4.1.1 fork 流程分析

**系统调用过程：**
```
用户态: fork() -> sys_fork()
       ↓
内核态: syscall() -> sys_fork() -> do_fork()
```

**do_fork() 关键步骤：**

1. **分配进程控制块**
   ```c
   proc = alloc_proc();
   proc->parent = current;
   ```
   - 创建新的 `proc_struct`
   - 设置父进程指针
   - 确保父进程不处于等待状态

2. **分配内核栈**
   ```c
   setup_kstack(proc);
   ```
   - 为子进程分配 2 页的内核栈空间

3. **复制内存空间**
   ```c
   copy_mm(clone_flags, proc);
   ```
   - 如果 `clone_flags & CLONE_VM`，则共享内存（线程）
   - 否则调用 `dup_mmap()` 复制父进程的所有 VMA
   - `dup_mmap()` 遍历父进程的 VMA 链表，调用 `copy_range()` 复制每个页面

4. **设置 trapframe 和上下文**
   ```c
   copy_thread(proc, stack, tf);
   ```
   - 复制父进程的 trapframe 到子进程内核栈顶
   - 设置子进程的返回值为 0（`proc->tf->gpr.a0 = 0`）
   - 设置 `context.ra = forkret`，使子进程首次调度时从 `forkret` 开始执行

5. **加入进程管理结构**
   ```c
   proc->pid = get_pid();
   hash_proc(proc);
   set_links(proc);
   ```
   - 分配唯一的 PID
   - 加入哈希表便于查找
   - 设置进程家族关系（兄弟、子进程链表）

6. **唤醒子进程**
   ```c
   wakeup_proc(proc);
   ```
   - 设置子进程状态为 `PROC_RUNNABLE`
   - 子进程可被调度执行

**父子进程的区分：**
- 父进程：`do_fork()` 返回子进程的 PID（> 0）
- 子进程：从 `forkret` 开始执行，trapframe 中的 `a0` 寄存器为 0

#### 4.1.2 exec 流程分析

**系统调用过程：**
```
用户态: exec(name, binary, ...) -> sys_exec()
       ↓
内核态: syscall() -> sys_exec() -> do_execve()
```

**do_execve() 关键步骤：**

1. **参数检查和准备**
   ```c
   user_mem_check(mm, (uintptr_t)name, len, 0);
   memcpy(local_name, name, len);
   ```
   - 检查用户传入的参数是否合法
   - 复制程序名到内核空间

2. **释放旧的内存空间**
   ```c
   lsatp(boot_pgdir_pa);  // 切换到内核页表
   if (mm_count_dec(mm) == 0) {
       exit_mmap(mm);      // 取消所有 VMA 的映射
       put_pgdir(mm);      // 释放页目录
       mm_destroy(mm);     // 销毁 mm_struct
   }
   current->mm = NULL;
   ```
   - 切换到内核页表（避免访问即将释放的用户空间）
   - 释放进程原有的所有内存资源

3. **加载新程序**
   ```c
   load_icode(binary, size);
   ```
   - 解析 ELF 格式的二进制文件
   - 为新程序创建内存管理结构 `mm_struct`
   - 根据 ELF program header 建立 VMA 并加载代码段、数据段
   - 分配并映射用户栈
   - **设置 trapframe**（练习1）：配置用户态执行环境

4. **更新进程名**
   ```c
   set_proc_name(current, local_name);
   ```

**exec 的特点：**
- 在当前进程的上下文中执行，不创建新进程
- PID 保持不变，但内存空间完全改变
- 常与 fork 配合使用：`fork()` 创建子进程，然后子进程调用 `exec()` 加载新程序

#### 4.1.3 wait 流程分析

**系统调用过程：**
```
用户态: wait(NULL) / waitpid(pid, &code) -> sys_wait()
       ↓
内核态: syscall() -> sys_wait() -> do_wait()
```

**do_wait() 关键步骤：**

1. **查找子进程**
   ```c
   if (pid != 0) {
       // 等待指定 PID 的子进程
       proc = find_proc(pid);
       if (proc != NULL && proc->parent == current) {
           haskid = 1;
           if (proc->state == PROC_ZOMBIE) {
               goto found;
           }
       }
   } else {
       // 等待任意子进程
       proc = current->cptr;
       for (; proc != NULL; proc = proc->optr) {
           haskid = 1;
           if (proc->state == PROC_ZOMBIE) {
               goto found;
           }
       }
   }
   ```
   - `pid != 0`：等待特定 PID 的子进程
   - `pid == 0`：等待任意一个子进程（遍历子进程链表）

2. **等待子进程退出**
   ```c
   if (haskid) {
       current->state = PROC_SLEEPING;
       current->wait_state = WT_CHILD;
       schedule();
       goto repeat;
   }
   ```
   - 如果有子进程但都未退出，父进程进入睡眠状态
   - 设置等待状态为 `WT_CHILD`
   - 调用 `schedule()` 让出 CPU
   - 被唤醒后重新检查（`goto repeat`）

3. **回收子进程资源**
   ```c
   found:
   if (code_store != NULL) {
       *code_store = proc->exit_code;
   }
   unhash_proc(proc);      // 从哈希表移除
   remove_links(proc);     // 断开进程家族关系
   put_kstack(proc);       // 释放内核栈
   kfree(proc);            // 释放进程控制块
   return 0;
   ```
   - 获取子进程的退出码
   - 彻底释放子进程的所有资源
   - 只有在 `do_wait()` 之后，子进程才真正消失

#### 4.1.4 exit 流程分析

**系统调用过程：**
```
用户态: exit(error_code) -> sys_exit()
       ↓
内核态: syscall() -> sys_exit() -> do_exit()
```

**do_exit() 关键步骤：**

1. **释放内存资源**
   ```c
   struct mm_struct *mm = current->mm;
   if (mm != NULL) {
       lsatp(boot_pgdir_pa);  // 切换到内核页表
       if (mm_count_dec(mm) == 0) {
           exit_mmap(mm);      // 取消映射
           put_pgdir(mm);      // 释放页表
           mm_destroy(mm);     // 销毁 mm
       }
       current->mm = NULL;
   }
   ```
   - 释放进程的所有用户空间内存
   - 如果是共享内存（线程），只减少引用计数

2. **设置为僵尸状态**
   ```c
   current->state = PROC_ZOMBIE;
   current->exit_code = error_code;
   ```
   - 进程进入 ZOMBIE 状态（已死但未回收）
   - 保存退出码，供父进程的 `wait()` 获取

3. **唤醒父进程**
   ```c
   proc = current->parent;
   if (proc->wait_state == WT_CHILD) {
       wakeup_proc(proc);
   }
   ```
   - 如果父进程正在 `wait()` 中睡眠，唤醒它

4. **处理子进程**
   ```c
   while (current->cptr != NULL) {
       proc = current->cptr;
       // 将所有子进程过继给 initproc
       proc->parent = initproc;
       initproc->cptr = proc;
       // 如果子进程是僵尸，唤醒 initproc 回收
       if (proc->state == PROC_ZOMBIE) {
           if (initproc->wait_state == WT_CHILD) {
               wakeup_proc(initproc);
           }
       }
   }
   ```
   - 将所有子进程过继给 init 进程（PID=1）
   - 防止孤儿进程无法被回收

5. **调度其他进程**
   ```c
   schedule();
   panic("do_exit will not return!!");
   ```
   - 让出 CPU，调度其他进程
   - 永不返回（因为已经是僵尸状态）

### 3.2 进程生命周期总结

**完整的生命周期：**
```
     fork()                exec()              exit()              wait()
UNINIT → RUNNABLE → (运行) → RUNNABLE → (运行) → ZOMBIE → (被回收) → 完全消失
         ↓                                         ↑
         └─────── sleep/wait ────→ SLEEPING ───────┘
```

**状态转换：**
- `PROC_UNINIT`：初始化中
- `PROC_RUNNABLE`：可运行（等待调度或正在运行）
- `PROC_SLEEPING`：睡眠等待
- `PROC_ZOMBIE`：已退出但未回收

**关键点：**
1. **fork 不执行新程序**，只是复制当前进程
2. **exec 不创建新进程**，只是替换当前进程的内存空间
3. **exit 后进程变成僵尸**，资源尚未完全释放
4. **wait 彻底回收子进程**，释放所有资源
5. **孤儿进程**由 init 进程收养和回收

### 3.3 关键数据结构

#### proc_struct（进程控制块）
```c
struct proc_struct {
    enum proc_state state;      // 进程状态
    int pid;                    // 进程ID
    int runs;                   // 运行次数
    uintptr_t kstack;           // 内核栈地址
    volatile bool need_resched; // 需要重新调度
    struct proc_struct *parent; // 父进程
    struct mm_struct *mm;       // 内存管理结构
    struct context context;     // 上下文（寄存器）
    struct trapframe *tf;       // 中断帧
    uintptr_t pgdir;           // 页表基址（物理地址）
    uint32_t flags;            // 进程标志
    char name[PROC_NAME_LEN];  // 进程名
    list_entry_t list_link;    // 进程链表
    list_entry_t hash_link;    // 哈希表链表
    int exit_code;             // 退出码
    uint32_t wait_state;       // 等待状态
    struct proc_struct *cptr, *yptr, *optr; // 子进程/兄弟进程链表
};
```

---

## 五、问题与改进

### 5.1 遇到的问题

#### 问题1：TLB 刷新缺失导致页错误

**现象：**
- 进程 fork 后，子进程运行时发生 "unhandled page fault"
- exit 测试失败，子进程异常退出

**原因分析：**
```c
// libs/riscv.h 中的 lsatp 函数（修复前）
static inline void lsatp(unsigned long pgdir) {
    write_csr(satp, 0x8000000000000000 | (pgdir >> RISCV_PGSHIFT));
    // 缺少 TLB 刷新！
}
```

在进程切换时，`proc_run()` 调用 `lsatp()` 切换页表：
```c
void proc_run(struct proc_struct *proc) {
    if (proc != current) {
        current = proc;
        lsatp(next->pgdir);  // 切换页表
        switch_to(&(prev->context), &(next->context));
    }
}
```

**问题：**
- 修改 `satp` 寄存器后没有刷新 TLB
- TLB 中缓存了旧进程的虚拟地址→物理地址映射
- 新进程访问相同虚拟地址时，使用了错误的物理地址
- 导致访问非法内存，触发页错误

**解决方案：**
```c
static inline void lsatp(unsigned long pgdir) {
    write_csr(satp, 0x8000000000000000 | (pgdir >> RISCV_PGSHIFT));
    asm volatile("sfence.vma");  // 刷新TLB
}
```

`sfence.vma` 指令（Supervisor Fence Virtual Memory Address）：
- 刷新 TLB，使所有缓存的页表项失效
- 确保地址空间切换后使用新的页表映射

#### 问题2：输出交错（已解决）

**现象：**
- 多个进程同时输出时，字符交错
- 测试脚本的模式匹配失败

**原因：**
- 用户态 `cprintf()` 对每个字符调用一次 `sys_putc`
- 多进程并发时，字符输出被打断

**解决方案：**
- 在内核的 `sys_putc` 中实现行缓冲
- 遇到换行符时才整行输出，减少交错概率

### 5.2 重要知识点

#### （1）RISC-V 页表权限

RISC-V Sv39 的 PTE 权限位：
- `PTE_V (0x01)`：有效位
- `PTE_R (0x02)`：可读
- `PTE_W (0x04)`：可写
- `PTE_X (0x08)`：可执行
- `PTE_U (0x10)`：用户态可访问

**特殊规则：**
- **R=0, W=1 是保留组合**，硬件拒绝
- **可写页必须也可读**（`PTE_R | PTE_W`）

代码中的处理：
```c
int perm = PTE_V | PTE_U;
if (vma->vm_flags & VM_READ) perm |= PTE_R;
if (vma->vm_flags & VM_WRITE) perm |= (PTE_R | PTE_W);  // 注意这里
if (vma->vm_flags & VM_EXEC) perm |= PTE_X;
```

#### （2）进程地址空间布局

```
0x80000000 (USERTOP/USTACKTOP) ┬─────────────┐
                               │  User Stack │ 向下增长
                               ├─────────────┤
                               │             │
                               │   (未映射)   │
                               │             │
                               ├─────────────┤
                               │ Heap (堆)   │ 向上增长
                               ├─────────────┤
                               │ BSS 段      │ 未初始化数据
                               ├─────────────┤
                               │ Data 段     │ 已初始化数据
                               ├─────────────┤
0x00800000 (UTEXT)             │ Code 段     │ 程序代码
                               └─────────────┘
```

#### （3）上下文切换

两种上下文：
1. **中断上下文（trapframe）**：
   - 保存用户态/内核态切换时的所有寄存器
   - 用于系统调用、异常、中断的处理
   - 位于内核栈顶

2. **进程上下文（context）**：
   - 只保存 callee-saved 寄存器（ra, sp, s0-s11）
   - 用于进程间切换
   - 通过 `switch_to` 切换

---

## 六、测试结果

### 6.1 编译输出

```bash
$ make
+ cc kern/init/entry.S
+ cc kern/init/init.c
+ cc kern/libs/stdio.c
...
+ ld bin/kernel
riscv64-unknown-elf-objcopy bin/kernel --strip-all -O binary bin/ucore.img
```

编译成功，无错误。

### 6.2 测试分数

```bash
$ make grade
badsegment:              OK
divzero:                 OK
softint:                 OK
faultread:               OK
faultreadkernel:         OK
hello:                   OK
testbss:                 OK
pgdir:                   OK
yield:                   OK
badarg:                  OK
exit:                    OK
spin:                    OK
forktest:                OK
Total Score: 130/130
```

**所有测试通过！满分 130/130**

### 6.3 关键测试说明

#### exit 测试
- 父进程 fork 子进程
- 子进程执行 7 次 yield 后调用 exit
- 父进程通过 waitpid 等待子进程
- 验证了 fork、exit、wait 的正确性

#### forktest 测试
- 递归 fork 创建 31 个子进程
- 测试内存复制和进程管理的正确性
- 所有进程正常退出

---

## 七、实验总结

### 7.1 实验收获

1. **深入理解进程管理机制**
   - 掌握了进程创建（fork）、加载（exec）、等待（wait）、退出（exit）的完整流程
   - 理解了进程生命周期和状态转换

2. **理解用户态和内核态切换**
   - 学习了 RISC-V 的特权级切换机制
   - 掌握了 trapframe 的作用和设置方法
   - 理解了 `sret` 指令的工作原理

3. **掌握内存管理**
   - 实现了进程内存空间的复制
   - 理解了虚拟内存、页表、TLB 的关系
   - 认识到 TLB 刷新的重要性

4. **调试能力提升**
   - 通过页错误问题的排查，学会了系统级调试
   - 理解了并发问题的复杂性


---

